*neoconf.nvim.txt*           For Neovim          Last change: 2025 October 11

==============================================================================
Table of Contents                             *neoconf.nvim-table-of-contents*

1. neoconf.nvim                                    |neoconf.nvim-neoconf.nvim|
  - Features                              |neoconf.nvim-neoconf.nvim-features|
  - Requirements                      |neoconf.nvim-neoconf.nvim-requirements|
  - Installation                      |neoconf.nvim-neoconf.nvim-installation|
  - Setup                                    |neoconf.nvim-neoconf.nvim-setup|
  - Configuration                    |neoconf.nvim-neoconf.nvim-configuration|
  - Write Callback                  |neoconf.nvim-neoconf.nvim-write-callback|
  - Live Reload & Diff Method          |neoconf.nvim-neoconf.nvim-live-reload|
  - Settings Files & JSON Keys   |neoconf.nvim-neoconf.nvim-settings-files|
  - Usage                                    |neoconf.nvim-neoconf.nvim-usage|
  - Commands                              |neoconf.nvim-neoconf.nvim-commands|
  - Editor (temporary buffer)                |neoconf.nvim-neoconf.nvim-editor|
  - API                                        |neoconf.nvim-neoconf.nvim-api|
  - Acknowledgment                  |neoconf.nvim-neoconf.nvim-acknowledgment|
  - Supported Language Servers|neoconf.nvim-neoconf.nvim-supported-language-servers|
2. Links                                                  |neoconf.nvim-links|

==============================================================================
1. neoconf.nvim                                    *neoconf.nvim-neoconf.nvim*

**neoconf.nvim** is a Neovim plugin to manage global and project-local
settings.

FEATURES                                  *neoconf.nvim-neoconf.nvim-features*

- Configure Neovim using **JSON** files (comments supported via JSONC):
    - Global settings: `~/.config/nvim/neoconf.json`
    - Local settings:  `<project>/.neoconf.json`
- Live reload of your LSP settings (sends `workspace/didChangeConfiguration`)
- Import existing settings from:
    - VS Code <https://github.com/microsoft/vscode>
    - coc.nvim <https://github.com/neoclide/coc.nvim>
    - nlsp-settings.nvim <https://github.com/tamago324/nlsp-settings.nvim>
- Auto-completion/validation inside your **JSON** config files (via jsonls)
- Auto-completion of LSP settings in **Lua** files (via lua_ls annotations)
- Programmatic API to read **and write** settings:
    - `require("neoconf").get(...)`
    - `require("neoconf").set(path, value[, { scope = "local"|"global" }])`
    - helpers like `toggle_inlay_hints()`, `toggle_boolean()`, etc.
- Simple UI helpers to view/modify merged settings

REQUIREMENTS                          *neoconf.nvim-neoconf.nvim-requirements*

- Neovim >= 0.7.2

INSTALLATION                          *neoconf.nvim-neoconf.nvim-installation*

Install the plugin with your preferred package manager:

LAZY.NVIM ~

>lua
    { "folke/neoconf.nvim" }
<

SETUP                                        *neoconf.nvim-neoconf.nvim-setup*

It’s important that you set up `neoconf.nvim` **BEFORE** `nvim-lspconfig`.

>lua
    require("neoconf").setup({
      -- override any of the default settings here
    })
    
    -- setup your lsp servers as usual
    require("lspconfig").lua_ls.setup(...)
<

CONFIGURATION                        *neoconf.nvim-neoconf.nvim-configuration*

**neoconf.nvim** comes with the following defaults (Lua setup options):

>lua
    {
      -- Use cwd for neoconf root, prevents searching upwards outside the
      -- current project
      root_use_cwd = false,

      -- callback after a neoconf JSON file is written (see |neoconf.nvim-neoconf.nvim-write-callback|)
      on_write = function(event) end,

      -- name of the local settings file (relative to project root)
      local_settings  = ".neoconf.json",
      -- name of the global settings file (inside stdpath('config'))
      global_settings = "neoconf.json",

      -- import existing settings from other tools (merged into LSP configs)
      import = {
        vscode = true, -- .vscode/settings.json (local)
        coc    = true, -- coc-settings.json (global + local)
        nlsp   = true, -- nlsp-settings/*.json (global + local)
      },

      -- send didChangeConfiguration when JSON settings change
      live_reload = true,

      -- set filetype to jsonc for settings files (enables comments)
      -- make sure you have the jsonc treesitter parser installed!
      filetype_jsonc = true,

      -- keymap for saving the temporary editor buffer (see |neoconf.nvim-neoconf.nvim-editor|)
      save_keymap = "<leader>s",

      -- LSP change-detection method used for event.lsp_settings_changed
      -- See |neoconf.nvim-neoconf.nvim-live-reload|
      diff_method = "auto", -- "auto" | "jq" | "lua_optimized" | "lua_deep"

      plugins = {
        -- configures lsp clients with neoconf in this order:
        -- 1) settings passed in lspconfig setup
        -- 2) global neoconf: lspconfig.<server>
        -- 3) global imports: coc, nlsp.<server>
        -- 4) local  imports: vscode, coc, nlsp.<server>
        -- 5) local  neoconf: lspconfig.<server>
        lspconfig = { enabled = true },

        -- adds schema/completion for .neoconf.json (via jsonls)
        jsonls = {
          enabled = true,
          -- only show completion for servers that are configured in lspconfig
          configured_servers_only = true,
        },

        -- adds lua annotations & makes plugin types discoverable by lua_ls
        lua_ls = {
          -- by default, annotations enabled when editing your Neovim config
          enabled_for_neovim_config = true,
          -- explicitly enable annotations everywhere
          enabled = false,
        },
      },
    }
<

WRITE CALLBACK                      *neoconf.nvim-neoconf.nvim-write-callback*

The `on_write` callback allows you to hook into file write events for neoconf
JSON files. This is useful for implementing intelligent LSP restarts, custom
validation, or other reactive behaviors when configuration changes.

CALLBACK EVENT OBJECT ~

When a neoconf file is written, the callback receives an enhanced event object:

>lua
    {
      file = "/abs/path/.neoconf.json",          -- absolute path to the file
      is_global = false,                          -- true if global config file
      current_content = { ... },                  -- JSON after write
      previous_content = { ... },                 -- JSON before write
      lsp_settings_changed = true,                -- see |neoconf.nvim-neoconf.nvim-live-reload|
      raw_event = { ... }                         -- original BufWritePost data
    }
<

USAGE EXAMPLES ~

Intelligent LSP Restart:

>lua
    require("neoconf").setup({
      on_write = function(event)
        if event.lsp_settings_changed and not event.is_global then
          vim.cmd("LspRestart")
        end
      end,
    })
<

Custom Validation:

>lua
    require("neoconf").setup({
      on_write = function(event)
        local lua_ls = event.current_content.lspconfig
          and event.current_content.lspconfig.lua_ls
        if lua_ls and lua_ls.cmd and vim.fn.executable(lua_ls.cmd) == 0 then
          vim.notify("lua_ls executable not found: " .. lua_ls.cmd, vim.log.levels.WARN)
        end
      end,
    })
<

LIVE RELOAD & DIFF METHOD            *neoconf.nvim-neoconf.nvim-live-reload*

When a settings file is saved, the plugin computes whether anything under the
top-level **`lsp`** object changed and exposes that as `event.lsp_settings_changed`
in the write callback. The diff method is configurable:

- `"auto"`: try `jq` (fast), fallback to `lua_optimized`
- `"jq"`: uses the `jq` command to compare JSON
- `"lua_optimized"`: compares `vim.json.encode`d strings
- `"lua_deep"`: deep recursive table compare (thorough but slow)

Note: only the `lsp` sub-tree is considered for this flag. Your callback can
still inspect `event.current_content` for anything else.

SETTINGS FILES & JSON KEYS      *neoconf.nvim-neoconf.nvim-settings-files*

Neoconf reads from:

- **Global**: `stdpath("config")/neoconf.json`
- **Local**:  `<project>/.neoconf.json`

Files are parsed as **JSONC** (comments allowed). Completion/validation for
`.neoconf.json` is provided via jsonls.

Common top-level keys you may use:

- **`lspconfig`** *(object)* — per-server settings that will be merged into the
  corresponding LSP client configuration. You may also **disable** a server by
  setting its key to `false`.

  Example:

>json
    {
      "lspconfig": {
        "lua_ls": {
          "settings": {
            "Lua": {
              "workspace": { "checkThirdParty": false },
              "diagnostics": { "globals": ["vim"] }
            }
          }
        },
        "jsonls": {
          "settings": {
            "json": {
              "validate": { "enable": true }
            }
          }
        },
        "eslint": false
      }
    }
<

- **`lsp`** *(object, optional)* — convenience bucket used by some helpers in
  this plugin. Example keys:
  - `inlay_hint` *(boolean)* — toggled by |neoconf.nvim-toggle_inlay_hints|.

>json
    { "lsp": { "inlay_hint": true } }
<

- **`neoconf`** *(object, optional)* — configure this plugin from JSON instead
  of Lua (same structure as `require("neoconf").setup({ ... })`):

>json
    {
      "neoconf": {
        "live_reload": true,
        "filetype_jsonc": true,
        "plugins": {
          "lua_ls": { "enabled": true }
        }
      }
    }
<

- **Other keys** — you can store arbitrary values your own config consumes.
  For instance, |neoconf.nvim-toggle_autoformat| writes an `autoformat` key.

IMPORT SOURCES (read-only) ~

When enabled in setup, neoconf will *also* read and merge (without modifying):

- `.vscode/settings.json`                  → merged into server settings
- `coc-settings.json` (global & local)     → merged
- `nlsp-settings/<server>.json` (global & local) → merged

The final LSP client settings merge order is:

1. Settings passed to `lspconfig.SERVER.setup({ settings = ... })`
2. Global `lspconfig.SERVER` from neoconf
3. Global imports: `coc`, `nlsp.SERVER`
4. Local  imports: `vscode`, `coc`, `nlsp.SERVER`
5. Local  `lspconfig.SERVER` from neoconf

USAGE                                        *neoconf.nvim-neoconf.nvim-usage*

COMPLETION AND VALIDATION FOR YOUR JSON SETTINGS FILES ~

- Works out of the box when `plugins.jsonls.enabled = true`.
- Files are treated as **jsonc** when `filetype_jsonc = true` (allows comments).

COMPLETION AND VALIDATION FOR YOUR LUA SETTINGS FILES ~

- Works out of the box when `plugins.lua_ls` is active for your config.
- Extra Lua annotations/types are added to make `lspconfig` settings discoverable.

Example (table of LSP server options):

>lua
      ---@type lspconfig.options
      local servers = {
        lua_ls = {},
        jsonls = {
          settings = {
            json = {
              format = { enable = true },
              validate = { enable = true },
            },
          },
        },
      }
<

COMMANDS                                  *neoconf.nvim-neoconf.nvim-commands*

- `:Neoconf`         — pick a local/global neoconf file to create/edit
- `:Neoconf local`   — pick a *local* neoconf file to create/edit
- `:Neoconf global`  — pick a *global* neoconf file to create/edit
- `:Neoconf show`    — floating window with merged config
- `:Neoconf lsp`     — floating window with merged LSP client settings
- `:Neoconf choose_client` — select an active LSP client and open an editor
  with its settings merged with neoconf (see |neoconf.nvim-neoconf.nvim-editor|)
- `:Neoconf checkhealth` — run health checks for neoconf integration

EDITOR (TEMPORARY BUFFER)                 *neoconf.nvim-neoconf.nvim-editor*

Neoconf provides a small editor workflow for inspecting & saving settings:

- `:Neoconf choose_client` opens a temporary buffer containing:
  - the merged neoconf settings,
  - **plus** the selected LSP client's current `settings`.
- Press `{save_keymap}` (default **`<leader>s`**) to validate JSON and write
  **only the local** neoconf settings back to `.neoconf.json`.
- The write triggers your `on_write` callback and updates caches just like a
  normal `:write`.

API                                            *neoconf.nvim-neoconf.nvim-api*

This section documents the **runtime Lua API** exposed by `require("neoconf")`.
All functions are safe to call from your `init.lua` or plugins.

GET SETTINGS ~

>lua
    --- Returns the requested settings (merged according to |neoconf.nvim-neoconf.nvim-settings-files|)
    ---@generic T : table
    ---@param key? string      Optional key to fetch (dot-path). When omitted, returns all settings.
    ---@param defaults? T      Defaults merged into the result when the key is missing/partial.
    ---@param opts? WorkspaceOptions  See below.
    ---@return T
    require("neoconf").get(key, defaults, opts)
<

>lua
    ---@class WorkspaceOptions
    ---@field file?   string  File used to determine the root_dir
    ---@field buffer? integer Buffer used to determine the root_dir
    ---@field lsp?    boolean When true, try using active LSP root
    ---@field local?  boolean Merge local settings (default: true)
    ---@field global? boolean Merge global settings (default: true)
<

SET A VALUE (CREATE PATHS)                          *neoconf.nvim-set* *neoconf.nvim.set()*

>lua
    --- Ensure a JSON path exists and set its value. Creates intermediate objects.
    --- Triggers the same write flow as editing the file (on_write, live reload, cache refresh).
    ---
    ---@param path string  Dot-separated path ("a.b.c")
    ---@param value any    JSON-encodable value (string|number|boolean|table|vim.NIL)
    ---@param opts? { scope?: "local"|"global" }  -- default: "local"
    ---@return boolean|nil ok, string|nil err
    require("neoconf").set("editor.formatOnSave", true)
    require("neoconf").set("lsp.inlay_hint", false)
    require("neoconf").set("lspconfig.lua_ls.settings.Lua.telemetry.enable", vim.NIL)
<

Notes:
- **Type mapping** follows `vim.json.encode`:
  - `string`, `number`, `boolean` → JSON primitives
  - Lua **tables**:
    - Lists (1..n integer keys) → JSON arrays
    - Maps (non-sequence keys)   → JSON objects
  - Use **`vim.NIL`** to write JSON `null` (Lua `nil` cannot be encoded).
- If an intermediate key exists but is not an object (or is a list), it is
  **overwritten** with an empty object to create the path.
- `opts.scope = "global"` targets `stdpath("config")/neoconf.json`.
  Default is `"local"` → `<project>/.neoconf.json`.

TOGGLE HELPERS & UTILITIES ~

Toggle a boolean anywhere:                         *neoconf.nvim-toggle_boolean*

>lua
    ---@return boolean|nil new_value, string|nil error
    require("neoconf").toggle_boolean("some.feature.enabled")
<

Toggle a string inside a list (add/remove):   *neoconf.nvim-toggle_string_in_table*

>lua
    ---@return boolean|nil success, string|nil error
    require("neoconf").toggle_string_in_table("typescript", "features.languages")
<

Toggle LSP inlay hints:                         *neoconf.nvim-toggle_inlay_hints*

- Computes the current effective state (prefers explicit `lsp.inlay_hint` in
  neoconf, otherwise asks the active LSP).
- Writes the new value to **local** `.neoconf.json` under `lsp.inlay_hint`.
- Tries to apply the change immediately via `vim.lsp.inlay_hint.enable`.

>lua
    ---@return boolean|nil new_state
    require("neoconf").toggle_inlay_hints()
<

Toggle a generic `autoformat` flag:          *neoconf.nvim-toggle_autoformat*

- Convenience helper that toggles a top-level `autoformat` key in local
  settings. Many configs check this flag to enable/disable format-on-save.

>lua
    ---@return boolean|nil new_state
    require("neoconf").toggle_autoformat()
<

Print the current state of a setting:    *neoconf.nvim-print_property_state*

>lua
    require("neoconf").print_property_state("Inlay hints", "lsp.inlay_hint")
<

PLUGIN INTEGRATION API (for plugin authors) ~

Register to extend the JSON schema so users get completion in `.neoconf.json`:

>lua
    ---@class SettingsPlugin
    ---@field name string
    ---@field setup fun()|nil
    ---@field on_update fun(event)|nil
    ---@field on_schema fun(schema: Schema)

    require("neoconf.plugins").register({
      name = "myplugin",
      on_schema = function(schema)
        schema:import("myplugin", {
          doit = true,
          count = 1,
          array = {},
        })
        -- You can refine the auto-generated schema:
        schema:set("myplugin.array", {
          description = "Booleans or integers",
          anyOf = { { type = "boolean" }, { type = "integer" } },
        })
      end,
    })

    -- Later in your plugin:
    local cfg = require("neoconf").get("myplugin", { doit = false, count = 0 })
<

ACKNOWLEDGMENT                      *neoconf.nvim-neoconf.nvim-acknowledgment*

- json.lua <https://github.com/actboy168/json.lua> a pure-lua JSON library for
  parsing `jsonc` files

SUPPORTED LANGUAGE SERVERS*neoconf.nvim-neoconf.nvim-supported-language-servers*

- als <https://github.com/AdaCore/ada_language_server/tree/master/integration/vscode/ada/package.json>
- astro <https://github.com/withastro/language-tools/tree/main/packages/vscode/package.json>
- awkls <https://github.com/Beaglefoot/awk-language-server/tree/master/client/package.json>
- basedpyright <https://github.com/DetachHead/basedpyright/tree/main/packages/vscode-pyright/package.json>
- bashls <https://github.com/bash-lsp/bash-language-server/tree/master/vscode-client/package.json>
- clangd <https://github.com/clangd/vscode-clangd/tree/master/package.json>
- cssls <https://github.com/microsoft/vscode/tree/main/extensions/css-language-features/package.json>
- dartls <https://github.com/Dart-Code/Dart-Code/tree/master/package.json>
- denols <https://github.com/denoland/vscode_deno/tree/main/package.json>
- elixirls <https://github.com/elixir-lsp/vscode-elixir-ls/tree/master/package.json>
- elmls <https://github.com/elm-tooling/elm-language-client-vscode/tree/master/package.json>
- eslint <https://github.com/microsoft/vscode-eslint/tree/master/package.json>
- flow <https://github.com/flowtype/flow-for-vscode/tree/master/package.json>
- fsautocomplete <https://github.com/ionide/ionide-vscode-fsharp/tree/main/release/package.json>
- grammarly <https://github.com/znck/grammarly/tree/main/extension/package.json>
- haxe_language_server <https://github.com/vshaxe/vshaxe/tree/master/package.json>
- hhvm <https://github.com/slackhq/vscode-hack/tree/master/package.json>
- hie <https://github.com/alanz/vscode-hie-server/tree/master/package.json>
- html <https://github.com/microsoft/vscode/tree/main/extensions/html-language-features/package.json>
- intelephense <https://github.com/bmewburn/vscode-intelephense/tree/master/package.json>
- java_language_server <https://github.com/georgewfraser/java-language-server/tree/master/package.json>
- jdtls <https://github.com/redhat-developer/vscode-java/tree/master/package.json>
- jsonls <https://github.com/microsoft/vscode/tree/master/extensions/json-language-features/package.json>
- julials <https://github.com/julia-vscode/julia-vscode/tree/master/package.json>
- kotlin_language_server <https://github.com/fwcd/vscode-kotlin/tree/master/package.json>
- ltex <https://github.com/valentjn/vscode-ltex/tree/develop/package.json>
- lua_ls <https://github.com/LuaLS/vscode-lua/tree/master/package.json>
- luau_lsp <https://github.com/JohnnyMorganz/luau-lsp/tree/main/editors/code/package.json>
- omnisharp <https://github.com/OmniSharp/omnisharp-vscode/tree/master/package.json>
- perlls <https://github.com/richterger/Perl-LanguageServer/tree/master/clients/vscode/perl/package.json>
- perlnavigator <https://github.com/bscan/PerlNavigator/tree/main/package.json>
- perlpls <https://github.com/FractalBoy/perl-language-server/tree/master/client/package.json>
- powershell_es <https://github.com/PowerShell/vscode-powershell/tree/main/package.json>
- psalm <https://github.com/psalm/psalm-vscode-plugin/tree/master/package.json>
- puppet <https://github.com/puppetlabs/puppet-vscode/tree/master/package.json>
- purescriptls <https://github.com/nwolverson/vscode-ide-purescript/tree/master/package.json>
- pylsp <https://github.com/python-lsp/python-lsp-server/tree/develop/pylsp/config/schema.json>
- pyright <https://github.com/microsoft/pyright/tree/master/packages/vscode-pyright/package.json>
- r_language_server <https://github.com/REditorSupport/vscode-r-lsp/tree/master/package.json>
- rescriptls <https://github.com/rescript-lang/rescript-vscode/tree/master/package.json>
- rls <https://github.com/rust-lang/vscode-rust/tree/master/package.json>
- rome <https://github.com/rome/tools/tree/main/editors/vscode/package.json>
- ruff_lsp <https://github.com/astral-sh/ruff-vscode/tree/main/package.json>
- rust_analyzer <https://github.com/rust-analyzer/rust-analyzer/tree/master/editors/code/package.json>
- solargraph <https://github.com/castwide/vscode-solargraph/tree/master/package.json>
- solidity_ls <https://github.com/juanfranblanco/vscode-solidity/tree/master/package.json>
- sonarlint <https://github.com/SonarSource/sonarlint-vscode/tree/master/package.json>
- sorbet <https://github.com/sorbet/sorbet/tree/master/vscode_extension/package.json>
- sourcekit <https://github.com/swift-server/vscode-swift/tree/main/package.json>
- spectral <https://github.com/stoplightio/vscode-spectral/tree/master/package.json>
- stylelint_lsp <https://github.com/bmatcuk/coc-stylelintplus/tree/master/package.json>
- svelte <https://github.com/sveltejs/language-tools/tree/master/packages/svelte-vscode/package.json>
- svlangserver <https://github.com/eirikpre/VSCode-SystemVerilog/tree/master/package.json>
- tailwindcss <https://github.com/tailwindlabs/tailwindcss-intellisense/tree/master/packages/vscode-tailwindcss/package.json>
- terraformls <https://github.com/hashicorp/vscode-terraform/tree/master/package.json>
- tinymist <https://github.com/Myriad-Dreamin/tinymist/refs/heads/main/editors/vscode/package.json>
- ts_ls <https://github.com/microsoft/vscode/tree/main/extensions/typescript-language-features/package.json>
- typst_lsp <https://github.com/nvarner/typst-lsp/refs/heads/master/editors/vscode/package.json>
- volar <https://github.com/vuejs/language-tools/tree/master/extensions/vscode/package.json>
- vtsls <https://github.com/yioneko/vtsls/tree/main/packages/service/configuration.schema.json>
- vuels <https://github.com/vuejs/vetur/tree/master/package.json>
- wgls_analyzer <https://github.com/wgsl-analyzer/wgsl-analyzer/tree/master/editors/code/package.json>
- yamlls <https://github.com/redhat-developer/vscode-yaml/tree/master/package.json>
- zeta_note <https://github.com/artempyanykh/zeta-note-vscode/tree/master/package.json>
- zls <https://github.com/zigtools/zls-vscode/tree/master/package.json>

==============================================================================
2. Links                                                  *neoconf.nvim-links*

1. *image*: https://user-images.githubusercontent.com/292349/202160538-3711693c-14fd-4e8b-a9d1-ceda88bae00c.png
2. *image*: https://user-images.githubusercontent.com/292349/202161064-16789740-f094-4729-97c2-b6509148a7fd.png
3. *image*: https://user-images.githubusercontent.com/292349/202160792-f956e3af-535f-4ad6-8de4-d89854072f91.png
4. *image*: https://user-images.githubusercontent.com/292349/202160675-ea9a62b4-7084-40a3-966e-e9d5f0fb70ec.png

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
